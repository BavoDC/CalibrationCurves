---
title: "Mixed model calibration (MIX-C)"
author:
  - name: Lasai Barre√±ada
    orcid: 0000-0001-8020-0210
    email: lasai.barrenadataleb@kueleuven.be
    affiliations:
      - name: Department of Development and Regeneration, KU Leuven, Belgium
format:
  html:
    toc: true
    toc_float: true
    toc_depth: 3
    number_sections: true
    code_folding: hide
    code-fold: true
    theme: readable
    fig-width: 8
    fig-height: 6

---
  
```{r setup, include=FALSE}
library(dplyr)
library(ggplot2)
library(metafor)
library(meta)
library(plotrix)
library(ggnewscale)
library(rms)
library(merTools)
```

## Method Overview

In this approach, we estimate the observed proportion as

$$
\hat{p}^{(o)}_{ij} = \text{logit}^{-1} \left[ \hat{s}\left( \text{logit}(\hat{\pi}(x_{ij})) \right) + \tilde{s}_j \, \hat{\left( \text{logit}(\hat{\pi}(x_{ij})) \right)} \right]
$$

where $\hat{s}$ and $\tilde{s}_j$ denote the estimated smooth effects.  
We take the variance of both the fixed and random components into account when calculating the variance of the linear predictor, and we approximate the standard error of $\hat{p}^{(o)}_{ij}$ using the delta method.

To keep the confidence interval within $[0, 1]$, we construct the interval as:

$$
\min \left( 1, \max\left( 0, \hat{p}^{(o)}_{ij} \mp z_{1-\alpha/2} \, \text{se}\left( \hat{p}^{(o)}_{ij} \right) \right) \right)
$$

where $z_{1-\alpha/2}$ denotes the quantile of the standard normal distribution that corresponds to the cumulative probability of $1 - \alpha/2$ (i.e., $1.96$ for a 95% CI).

Prediction intervals are calculated using the `predictInterval` function in **R** with 10,000 samples (simulation-based).  
This function takes into account:

- The uncertainty at the observation level (residual variance)
- The fixed coefficients
- The random effects

In this method:

1. We first obtain the random and fixed effects.
2. We generate $n$ samples (default = 10,000) based on a multivariate normal distribution of the random and fixed effects, separately.
3. We calculate the linear predictor in each sample.
4. We predict the upper and lower limits of the prediction interval.

Detailed methodological overview can be found in the published [article](https://doi.org/10.48550/arXiv.2503.08389).
---
  
## The `MIXC` Function

```{r}
MIXC <- function(data = NULL, preds, cluster, y, model = "slope", nsims_pi = 10000, CI = TRUE, length_grid = 100, plot = TRUE, center_curves = FALSE, CI_method = "") {
  #' Generate Calibration Plots for Mixed-Effects Models
  #'
  #' This function generates calibration plots for mixed-effects models, assessing the agreement
  #' between predicted probabilities (log odds) and observed binary outcomes while accounting for
  #' clustering within the data.
  #'
  #' @param data Optional data frame containing the variables specified in `logit_preds`, `cluster`,
  #'   and `y`. If not provided, these arguments must be supplied as vectors.
  #' @param preds A numeric vector of predicted probabilities. If `data` is provided, this should
  #'   be the name of the column containing predictions.
  #' @param cluster A factor or character vector (or column name if `data` is provided) specifying
  #'   the clusters/centers corresponding to each prediction.
  #' @param y A numeric or factor vector (or column name if `data` is provided) representing the
  #'   observed binary outcomes (0 or 1).
  #' @param model Character string specifying the type of mixed-effects model. Options are `"intercept"`
  #'   for a random intercept model or `"slope"` for a random slope model. Default is `"slope"`.
  #' @param nsims_pi Integer specifying the number of simulations for calculating prediction intervals.
  #'   Default is 10,000.
  #' @param CI Logical indicating whether to calculate and include confidence intervals in the plot.
  #'   Default is `FALSE`.
  #' @param length_grid Integer specifying the number of points for the prediction grid. Default is 100.
  #' @param plot Logical indicating whether to generate a plot. Default is `TRUE`.
  #' @param center_curves Logical indicating whether to include calibration curves for individual centers
  #'   in the plot. Default is `FALSE`.
  #'
  #' @return A list containing:
  #'   \describe{
  #'     \item{model}{The fitted mixed-effects model object.}
  #'     \item{bycenter}{Data frame of calibration plot data for each center.}
  #'     \item{average}{Data frame of calibration plot data for the average center.}
  #'     \item{bypatient}{Data frame of calibration plot data for individual patients.}
  #'     \item{plot}{A `ggplot` object if `plot = TRUE`, otherwise `NULL`.}
  #'   }
  #'
  #' @details
  #' This function fits a mixed-effects logistic regression model to the input data, where clustering
  #' is accounted for by including random effects. The type of model is determined by the `model`
  #' parameter, which can specify either a random intercept model or a random slope model. Calibration
  #' plots are generated to visualize the relationship between predicted probabilities and observed
  #' outcomes, including options to display confidence and prediction intervals.
  #'
  #' @examples
  #' # Example usage with simulated data:
  #' set.seed(123)
  #' data <- data.frame(
  #'   preds = rnorm(100),
  #'   y = rbinom(100, 1, 0.5),
  #'   cluster = rep(1:10, each = 10)
  #' )
  #' result <- MIXC(data = data, preds = preds, cluster = cluster, y = y,
  #'                model = "slope", CI = TRUE)
  #'
  #' # View the calibration plot:
  #' print(result$plot)
  #'
  #' @import dplyr
  #' @import ggplot2
  #' @import lme4
  #' @import merTools
  #' @importFrom stats plogis qlogis predict
  #' @importFrom Matrix tcrossprod
  #' @export

  library(merTools)
  grid <- seq(0.01, 0.99, length.out = length_grid)

  if (!is.null(data)) {
    logit_preds <- qlogis(data[[deparse(substitute(preds))]])
    y <- as.factor(data[[deparse(substitute(y))]])
    cluster <- data[[deparse(substitute(cluster))]]
  } else {
    logit_preds <- qlogis(preds)
  }
  predicted_probability <- data.frame(logit_preds = logit_preds, y = as.factor(y), center = as.factor(cluster))

  if (typeof(model) != "S4") {
    if (model == "intercept") {
      fit_model <- lme4::glmer(y ~ rcs(logit_preds, 3) + (1 | center), data = predicted_probability, family = "binomial", verbose = 0)
    } else if (model == "slope") {
      fit_model <- lme4::glmer(y ~ rcs(logit_preds, 3) + (rcs(logit_preds, 3) | center), data = predicted_probability, family = "binomial", verbose = 0)
    }
  }

  predicted_probability$re_preds <- predict(fit_model, predicted_probability)
  predicted_probability$obs_itc <- plogis(predicted_probability$re_preds)

  min_max <- predicted_probability %>%
    group_by(center) %>%
    summarise(min = min(logit_preds), max = max(logit_preds))

  calplotdata_all <- data.frame()

  for (i in 1:nrow(min_max)) {
    p_pred_logit <- qlogis(grid)
    center <- rep(min_max$center[i], length_grid)
    calplotdata <- data.frame(center = center, logit_preds = p_pred_logit)
    calplotdata$x <- grid
    calplotdata$p_obs_logit <- predict(fit_model, newdata = calplotdata)
    calplotdata$p_pred <- plogis(calplotdata$logit_preds)
    calplotdata$p_obs <- plogis(calplotdata$p_obs_logit)
    calplotdata_all <- rbind(calplotdata_all, calplotdata)
  }

  logit_preds <- qlogis(grid)
  calplotdata <- data.frame(logit_preds = logit_preds)
  calplotdata$p_obs_logit <- predict(fit_model, newdata = calplotdata, re.form = NA)
  calplotdata$p_pred <- plogis(calplotdata$logit_preds)
  calplotdata$p_obs <- plogis(calplotdata$p_obs_logit)
  calplotdata$x <- grid

  if (CI) {
    deltaCI <- function(eta, se, alpha) {
      muHat <- plogis(eta)
      seMu <- binomial()$mu.eta(eta) * se
      data.frame(
        yHat       = muHat,
        lowerDelta = pmax(0, pmin(muHat + qnorm(alpha / 2) * seMu, 1)),
        upperDelta = pmax(0, pmin(muHat + qnorm(1 - alpha / 2) * seMu, 1))
      )
    }
    mm <- model.matrix(~ rcs(logit_preds, 3), calplotdata)
    # fixed effectt
    pvar1 <- diag(mm %*% Matrix::tcrossprod(stats::vcov(fit_model), mm))
    # Random effect
    # Delta method
    if (CI_method == "delta") {
      tvar1 <- pvar1 + VarCorr(fit_model)$center[1]

      calplotdata$p_plo <- deltaCI(calplotdata$p_obs_logit, sqrt(tvar1), 0.05)$lowerDelta
      calplotdata$p_phi <- deltaCI(calplotdata$p_obs_logit, sqrt(tvar1), 0.05)$upperDelta
      calplotdata$plo <- qlogis(calplotdata$p_plo)
      calplotdata$phi <- qlogis(calplotdata$p_phi)
    } else {
      calplotdata$plo <- calplotdata$p_obs_logit - 1.96 * sqrt(pvar1)
      calplotdata$phi <- calplotdata$p_obs_logit + 1.96 * sqrt(pvar1)
      calplotdata$p_plo <- plogis(calplotdata$plo)
      calplotdata$p_phi <- plogis(calplotdata$phi)
    }



    calplotdata$center <- "average"

    PI <- merTools::predictInterval(
      merMod = fit_model, newdata = calplotdata,
      level = 0.95, n.sims = nsims_pi,
      stat = "median", type = "probability",
      include.resid.var = TRUE
    )
    calplotdata <- cbind(calplotdata, PI)
  }

  if (plot) {
    mixed_plot <- ggplot(calplotdata) +
      geom_abline(linetype = "dashed", alpha = 0.1) +
      xlab("Estimated probability") +
      ylab("Observed proportion") +
      theme_classic(base_size = 8, base_family = "serif") +
      theme(
        legend.key.size = unit(0.3, "cm"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()
      ) +
      scale_x_continuous(breaks = seq(0, 1, 0.1)) +
      scale_y_continuous(breaks = seq(0, 1, 0.2)) +
      coord_cartesian(xlim = c(0, 1), ylim = c(0, 1)) +
      geom_ribbon(aes(x = p_pred, ymin = p_plo, ymax = p_phi, fill = "CI 95%"), alpha = 0.3) +
      geom_ribbon(aes(x = p_pred, ymin = lwr, ymax = upr, fill = "PI 95%"), alpha = 0.2) +
      geom_line(aes(x = p_pred, y = p_obs), linewidth = 1, linetype = "dashed", color = "black") +
      scale_fill_manual(name = "Uncertainty", values = c("green4", "green"))
    if (center_curves) {
      mixed_plot <- mixed_plot + geom_line(data = calplotdata_all, aes(x = p_pred, y = p_obs, color = center), lwd = 0.2, lty = "dotted", show.legend = FALSE)
    }
  } else {
    mixed_plot <- NULL
  }

  calplotdata_patient <- data.frame()
  for (i in unique(cluster)) {
    calplotdata_p <- predicted_probability %>%
      filter(center == i)
    calplotdata_p <- data.frame(center = calplotdata_p$center, logit_preds = calplotdata_p$logit_preds)
    calplotdata_p$p_obs_logit <- predict(fit_model, newdata = calplotdata_p)
    calplotdata_p$p_pred <- plogis(calplotdata_p$logit_preds)
    calplotdata_p$p_obs <- plogis(calplotdata_p$p_obs_logit)
    calplotdata_patient <- rbind(calplotdata_patient, calplotdata_p)
  }

  return(list(model = fit_model, bycenter = calplotdata_all, average = calplotdata, bypatient = calplotdata_patient, plot = mixed_plot))
}
```

---
  
## Example: Simulated Clustered Data 

We use the superpopulation 1 from the simulation dataset presented in the published paper. Here we used one of the centers to train a model and then used the remaining centers to test the model performance (J = 15, N = 5000).
```{r}
data_test <- readRDS("data_test.rds")
```

---

## MIX-C

```{r}
result_mix <- MIXC(
  data = data_test,
  preds = preds,
  y = y,
  cluster = center,
  model = "slope",
  nsims_pi = 10000,
  CI = TRUE,
  length_grid = 100,
  CI_method = "")

result_mix$plot
```
### Center specific curves
```{r}
result_mix$plot + 
  geom_line(data = result_mix$bycenter, aes(x = x, y = p_obs, group = center), lwd = 0.5, show.legend = F, lty = "solid") +
  labs(title = "Center specific shrunken curves")
```


## Interpretation

- **Black (dashed)**: MIX-C pooled curve across clusters
- **Black (solid)**: Center specific curves (if `center_curves = TRUE`)
- **Green shaded areas**:
  - Light green = 95% Prediction Interval (expected calibration curve in new clusters)
  - Dark green = 95% Confidence Interval (expected calibration of the pooled curve it can be calculated with Delta method or normal approximation)



MIX-C is a mixed-effects logistic calibration model using restricted cubic splines with random intercepts and slopes per cluster, designed to account for both fixed and random effects in calibration. It performs especially well for cluster-specific calibration curves, particularly when sample sizes per cluster are small, due to its shrinkage properties. A limitation is that its prediction intervals can be inconsistently too narrow or too wide, and like other methods, it tends to underestimate between-cluster heterogeneity. Overall, MIX-C is recommended for producing cluster-specific calibration plots, while other methods may be preferred for average-effect curves.


  

  
  
---
## References
  
1.   Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). *Fitting Linear Mixed-Effects Models   Using lme4.* Journal of Statistical Software, 67(1), 1-48. doi:10.18637/jss.v067.i01.
2. Barre√±ada, L., Campo, B. D. C., Wynants, L., & Calster, B. V. (2025). *Clustered Flexible Calibration Plots For Binary Outcomes Using Random Effects Modeling* (No. arXiv:2503.08389). arXiv. https://doi.org/10.48550/arXiv.2503.08389

